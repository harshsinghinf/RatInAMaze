<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RatInAMaze</title>
    <link rel="stylesheet" href="./style.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  </head>
  <body onload="createMaze()">
    <div class="game">
      <div class="title">RAT IN A MAZE</div>
      <select id="levelSelect">
        <option value="1">Level 1</option>
        <option value="2">Level 2</option>
        <option value="3">Level 3</option>
        <option value="4">Level 4</option>
        <option value="5">Level 5</option>
      </select>
      <div class="gamealign">
        <div id="maze-container">
          <img id="rat" src="ratImage.jpg" alt="Rat" width="22.5px" height="22.5px" />
          <img
            id="food"
            src="cheese_transparent.png"
            alt="Cheese"
            width="22.5px"
            height="22.5px"
          />
        </div>
        <div id="myModal" class="modal">
          <div class="modal-content">
            <span class="close" onclick="closeModal()"> &times; </span>
            <img
              id="modalImg"
              src="Remy Ratatouille.jpeg"
              alt="Ratatouille Got the Cheese"
            />
            <div class="youwin">You Win</div>
          </div>
        </div>
        <div class="instructions">
          <p>
            <h2>Instructions</h2>
            <ol>
              <li>Use ArrowUp(↑) for going up</li>
              <li>Use ArrowDown(↓) for going down</li>
              <li>Use ArrowLeft(←) for going left</li>
              <li>Use ArrowRight(→) for going right</li>
              <li>Click on the Maze few times after changing the Level</li>
            </ol>
          </p>
        </div>
      </div>
    </div>

    <div class="theory">
      <div class="unbreakable-container">  
        <div class="unbreakable">
          <span class="un">RAT</span><span class="break">IN-A</span><span class="able">MAZE</span>
        </div>
        <div class="ks">Aut<img id="settings" src="settings_24dp_E8EAED_FILL0_wght400_GRAD0_opsz24.png" alt="o"/>mated...</div>
      </div>
      <p id="mult">It can be implemented in Multiple ways. But we'll use:-</p>
      <h1 class="word"><!-- BACKTRACKING --></h1>
      <h1 class="headings">INTRODUCTION</h1>
      <div class="textcontent">Backtracking is like trying different paths, and when you hit a dead end, you backtrack to the last choice and try a different route. In this article, we'll explore the basics of backtracking, how it works, and how it can help solve all sorts of challenging problems. It's like a method for finding the right way through a complex choices.</div>
      <h1 class="headings">What is BACKTRACKING?</h1>
      <div class="textcontent">Backtracking is a problem-solving algorithmic technique that involves finding a solution incrementally by trying different options and undoing them if they lead to a dead end. It is commonly used in situations where you need to explore multiple possibilities to solve a problem, like searching for a path in a maze or solving puzzles like Sudoku. When a dead end is reached, the algorithm backtracks to the previous decision point and explores a different path until a solution is found or all possibilities have been exhausted.</div>
      <center><div style="background-color: #ffc18b;border-radius: 10px;padding: 10px; width: 90%;font-size: 1.5rem;text-align-last: left;">Backtracking can be defined as a general algorithmic technique that considers searching every possible combination in order to solve a computational problem.</div></center>
      <h1 class="headings">Basic Terminologies</h1>
      <div class="textcontent">
        <ul>
          <li><strong>Candidate:</strong> A candidate is a potential choice or element that can be added to the current solution.</li>
          <li><strong>Solution:</strong> The solution is a valid and complete configuration that satisfies all problem constraints.</li>
          <li><strong>Partial Solution:</strong> A partial solution is an intermediate or incomplete configuration being constructed during the backtracking process.</li>
          <li><strong>Decision Space:</strong> The decision space is the set of all possible candidates or choices at each decision point.</li>
          <li><strong>Decision Point:</strong> A decision point is a specific step in the algorithm where a candidate is chosen and added to the partial solution.</li>
          <li><strong>Feasible Solution:</strong> A feasible solution is a partial or complete solution that adheres to all constraints.</li>
          <li><strong>Dead End:</strong> A dead end occurs when a partial solution cannot be extended without violating constraints.</li>
          <li><strong>Backtrack:</strong>Backtracking involves undoing previous decisions and returning to a prior decision point.</li>
          <li><strong>Search Space:</strong> The search space includes all possible combinations of candidates and choices.</li>
          <li><strong>Optimal Solution:</strong>In optimization problems, the optimal solution is the best possible solution.</li>
        </ul>
      </div>
      <h1 class="headings">How does Backtracking Works?</h1>
      <center><div class="btworks" style="background-color: #ffc18b;border-radius: 10px;padding: 10px; width: 90%;font-size: 1.5rem;text-align-last: left;">As we know backtracking algorithm explores each and every possible path in order to find a valid solution, this exploration of path can be easily understood via given images:<br>
        <img class="btflow" src="BacktrackingFlow.png" alt="BackTracking_Flow"><br>
        As shown in the image, “IS”  represents the Initial State where the recursion call starts to find a valid solution.<br>
        C : it represents different Checkpoints for recursive calls
        <br>
        <br>
        TN: it represents the Terminal Nodes where no further recursive calls can be made, these nodes act as base case of recursion and we determine whether the current solution is valid or not at this state.
        <br>
        <br>
        At each Checkpoint, our program makes some decisions and move to other checkpoints untill it reaches a terminal Node, after determining whether a solution is valid or not, the program starts to revert back to the checkpoints and try to explore other paths. For example in the above image TN1…TN5 are the terminal node where the solution is not acceptable, while TN6 is the state where we found a valid solution.
        <br>
        <br>        
        The back arrows in the images shows backtracking in actions, where we revert the changes made by some checkpoint.
      </div></center>
      <h1 class="headings">Pseudocode for Backtracking</h1>
      <div class="textcontent">The best way to implement backtracking is through recursion, and all backtracking code can be summarised as per the given Pseudocode: <br><br>
        <center><div style="background-color: #ffc18b;border-radius: 10px;padding: 10px; width: 90%;font-size: 1.5rem;text-align-last: left;">
          <pre>

            void FIND_SOLUTIONS( parameters):

              if (valid solution):

                store the solution

                Return

              for (all choice):

                if (valid choice):

                  APPLY (choice)

                  FIND_SOLUTIONS (parameters)

                  BACKTRACK (remove choice)

              Return

          </pre>
        </div></center>
      </div>
      <h1 class="headings">Complexity Analysis of Backtracking</h1>
      <div class="textcontent">Since backtracking algorithm is purely brute force therefore in terms of time complexity, it performs very poorly. Generally backtracking can be seen having below mentioned time complexities: <br>
        <ul>
          <li>Exponential (O(K^N))</li>
          <li>Factorial (O(N!))</li>
        </ul>
        These complexities are due to the fact that at each state we have multiple choices due to which the number of paths increases and sub-trees expand rapidly. <br>
      </div>
      <h1 class="headings">Applications of Backtracking</h1>
      <div class="textcontent">
        <ul>
          <li>Creating smart bots to play Board Games such as Chess.</li>
          <li>Solving mazes and puzzles such as N-Queen problem.</li>
          <li>Network Routing and Congestion Control.</li>
          <li>Decryption</li>
          <li>Text Justification</li>
        </ul>
      </div>
      <h1 class="headings">Rat in a Maze - BackTracking</h1>
      <div class="explanation" style=" line-height: 1.6; margin: auto; padding: 10px; background-color: #ffc18b; border-radius: 4px; box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);">
        <h1 style="text-align: center; color: #333;">Backtracking in Maze Solving</h1>
        
        <p>Imagine you are helping a rat navigate through a maze to reach a piece of food. The rat starts at a specific point, and your job is to guide it by trying different directions. You don't know the path to the food in advance, so you have to explore all the possible ways the rat can move. This process is called <strong>backtracking</strong>.</p>
        
        <h2>How Backtracking Works:</h2>
      
        <h3>1. Starting Point:</h3>
        <p>The rat begins at its starting position in the maze. From here, it needs to try moving in different directions (down, right, up, or left) to find the food.</p>
      
        <h3>2. Checking for Food:</h3>
        <p>At every step, the rat checks whether it has reached the food. If it finds the food, it stops, and the path to the food is marked as <strong>successful</strong>.</p>
      
        <h3>3. Moving in Different Directions:</h3>
        <p>If the rat doesn't find the food immediately, it tries to move in different directions, one by one:</p>
        <ul style="margin-left: 20px;">
          <li>Move down: The rat first tries to go down.</li>
          <li>Move right: If it can't move down, it tries moving to the right.</li>
          <li>Move up: If it can't move down or right, it tries moving upward.</li>
          <li>Move left: Finally, if none of the previous directions worked, it tries moving to the left.</li>
        </ul>
      
        <h3>4. Valid Moves:</h3>
        <p>While moving, the rat can only step on spaces that are open (not walls) and hasn't been visited before. If the rat hits a wall or tries to move outside the maze, it knows it can’t go in that direction.</p>
      
        <h3>5. Marking Visited Spaces:</h3>
        <p>As the rat moves, it marks the spaces it has already visited, so it doesn’t try the same place again. These spaces might change colors to show the rat has explored them.</p>
      
        <h3>6. Finding the Food:</h3>
        <p>If the rat finds a way to reach the food, the path it took is marked as <strong>green</strong> (or a success color), and the game ends. The rat has successfully reached its goal!</p>
      
        <h3>7. Backtracking (Going Back):</h3>
        <p>If the rat gets stuck (meaning it has tried all possible directions but none lead to the food), it will <strong>backtrack</strong>. Backtracking means the rat returns to the previous position it came from, marking the place it got stuck in as <strong>red</strong> (a failure color).</p>
        <p style="background-color: #f7af6f; border-left: 4px solid #0077be; padding-left: 10px;">The rat will continue trying different paths until it either finds the food or runs out of options.</p>
      
        <h3>8. No Path Available:</h3>
        <p>If the rat eventually returns to its starting position and there are no more directions to try, it concludes that there’s <strong>no way to reach the food</strong>, and the game will notify you that no path is available.</p>
      
        <h2 style="color: #2c3e50;">In Simple Terms:</h2>
        <p>Imagine you're guiding a rat in a maze where you don’t know the way out. You tell the rat to move in one direction, and if it can't continue, it comes back and tries another route. The rat keeps doing this until it finds the food or realizes there’s no way to reach it. The rat remembers where it has been, so it doesn’t get lost or go in circles. If it finds the food, the path is marked as successful; if not, it shows where it got stuck.</p>
        
        <p>This process of trying, going back, and trying again is how <strong>backtracking</strong> works. It’s like a smart way of solving a puzzle where you explore every possibility but go back if things don’t work out.</p>

        <h1>Flow Expalaining BackTracking for Rat in a Maze</h1>
        <img src="Flowchart.png" alt="BackTrackingFlow" id="flowchart">
      </div>
    </div>

    <button id="loadGame" style="margin: 20px 50vw; margin-bottom: 7vh;">Load Game</button>

    <div class="game2">
      <div class="title">RAT IN A MAZE</div>
      <select id="levelSelect2">
        <option value="1">Level 1</option>
        <option value="2">Level 2</option>
        <option value="3">Level 3</option>
        <option value="4">Level 4</option>
        <option value="5">Level 5</option>
      </select>
      
      <div class="gamealign">
        <div id="maze-container2">
          <img id="rat2" src="ratImage.jpg" alt="Rat" width="24.5px" height="24.5px" />
          <img
            id="food2"
            src="cheese_transparent.png"
            alt="Cheese"
            width="24.5px"
            height="24.5px"
          />
        </div>
        <div class="buttons">
          <button class="start" value="start">Start</button>
          <button class="twoX" value="twoX">2x</button>
          <button class="threeX" value="threeX">3x</button>
          <button class="fourX" value="fourX">4x</button>
          <button class="reset" value="reset">Reset</button>
        </div>
      </div>
    </div>



    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.0.2/anime.min.js"></script>
    <script src="script.js"></script>
  </body>
</html>
